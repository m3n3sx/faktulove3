<!-- Network Status Indicator -->
<div id="networkStatusIndicator" class="network-status-indicator" style="display: none;">
    <div class="status-content">
        <div class="status-icon">
            <i class="fas fa-wifi" id="statusIcon"></i>
        </div>
        <div class="status-text">
            <span id="statusMessage">Sprawdzanie połączenia...</span>
            <div id="statusDetails" class="status-details"></div>
        </div>
        <div class="status-actions">
            <button id="retryConnection" class="btn-retry" style="display: none;">
                <i class="fas fa-redo"></i> Spróbuj ponownie
            </button>
            <button id="syncOfflineData" class="btn-sync" style="display: none;">
                <i class="fas fa-sync"></i> Synchronizuj
            </button>
        </div>
    </div>
    <div class="offline-queue" id="offlineQueue" style="display: none;">
        <div class="queue-header">
            <i class="fas fa-clock"></i>
            <span>Operacje oczekujące na synchronizację:</span>
        </div>
        <div class="queue-list" id="queueList"></div>
    </div>
</div>

<style>
.network-status-indicator {
    position: fixed;
    top: 20px;
    right: 20px;
    background: white;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    border: 1px solid #e9ecef;
    z-index: 9999;
    max-width: 400px;
    min-width: 300px;
    animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
    from {
        transform: translateX(100%);
        opacity: 0;
    }
    to {
        transform: translateX(0);
        opacity: 1;
    }
}

.status-content {
    padding: 1rem;
    display: flex;
    align-items: center;
    gap: 1rem;
}

.status-icon {
    font-size: 1.5rem;
    width: 40px;
    text-align: center;
}

.status-icon.online {
    color: #28a745;
}

.status-icon.offline {
    color: #dc3545;
    animation: pulse 2s infinite;
}

.status-icon.checking {
    color: #ffc107;
    animation: spin 1s linear infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.5; }
    100% { opacity: 1; }
}

@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.status-text {
    flex: 1;
}

.status-text span {
    font-weight: 600;
    color: #343a40;
    display: block;
}

.status-details {
    font-size: 0.85rem;
    color: #6c757d;
    margin-top: 0.25rem;
}

.status-actions {
    display: flex;
    gap: 0.5rem;
}

.btn-retry, .btn-sync {
    background: #007bff;
    color: white;
    border: none;
    padding: 0.5rem 1rem;
    border-radius: 6px;
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.3s ease;
}

.btn-retry:hover, .btn-sync:hover {
    background: #0056b3;
    transform: translateY(-1px);
}

.btn-sync {
    background: #28a745;
}

.btn-sync:hover {
    background: #1e7e34;
}

.offline-queue {
    border-top: 1px solid #e9ecef;
    background: #f8f9fa;
    border-radius: 0 0 12px 12px;
}

.queue-header {
    padding: 0.75rem 1rem;
    font-size: 0.9rem;
    font-weight: 600;
    color: #495057;
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.queue-list {
    max-height: 200px;
    overflow-y: auto;
}

.queue-item {
    padding: 0.5rem 1rem;
    border-bottom: 1px solid #e9ecef;
    font-size: 0.85rem;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.queue-item:last-child {
    border-bottom: none;
}

.queue-item-info {
    flex: 1;
}

.queue-item-operation {
    font-weight: 600;
    color: #495057;
}

.queue-item-time {
    color: #6c757d;
    font-size: 0.8rem;
}

.queue-item-status {
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: 600;
}

.queue-item-status.pending {
    background: #fff3cd;
    color: #856404;
}

.queue-item-status.syncing {
    background: #d1ecf1;
    color: #0c5460;
}

.queue-item-status.failed {
    background: #f8d7da;
    color: #721c24;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .network-status-indicator {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
        min-width: auto;
    }
    
    .status-content {
        padding: 0.75rem;
        gap: 0.75rem;
    }
    
    .status-actions {
        flex-direction: column;
        gap: 0.25rem;
    }
    
    .btn-retry, .btn-sync {
        padding: 0.4rem 0.8rem;
        font-size: 0.8rem;
    }
}

/* Hide indicator when printing */
@media print {
    .network-status-indicator {
        display: none !important;
    }
}
</style>

<script>
class NetworkStatusIndicator {
    constructor() {
        this.indicator = document.getElementById('networkStatusIndicator');
        this.statusIcon = document.getElementById('statusIcon');
        this.statusMessage = document.getElementById('statusMessage');
        this.statusDetails = document.getElementById('statusDetails');
        this.retryButton = document.getElementById('retryConnection');
        this.syncButton = document.getElementById('syncOfflineData');
        this.offlineQueue = document.getElementById('offlineQueue');
        this.queueList = document.getElementById('queueList');
        
        this.isOnline = navigator.onLine;
        this.checkInterval = null;
        this.syncInterval = null;
        this.offlineOperations = [];
        
        this.init();
    }
    
    init() {
        // Listen for online/offline events
        window.addEventListener('online', () => this.handleOnline());
        window.addEventListener('offline', () => this.handleOffline());
        
        // Setup button handlers
        this.retryButton.addEventListener('click', () => this.checkConnection());
        this.syncButton.addEventListener('click', () => this.syncOfflineData());
        
        // Initial status check
        this.checkConnection();
        
        // Start periodic checks
        this.startPeriodicChecks();
        
        // Load offline operations
        this.loadOfflineOperations();
    }
    
    handleOnline() {
        this.isOnline = true;
        this.updateStatus('online', 'Połączenie przywrócone', 'Synchronizacja danych...');
        this.syncOfflineData();
    }
    
    handleOffline() {
        this.isOnline = false;
        this.updateStatus('offline', 'Brak połączenia', 'Pracujesz w trybie offline');
        this.showIndicator();
    }
    
    async checkConnection() {
        this.updateStatus('checking', 'Sprawdzanie połączenia...', '');
        
        try {
            const response = await fetch('/api/health/network/', {
                method: 'GET',
                cache: 'no-cache',
                timeout: 5000
            });
            
            if (response.ok) {
                const data = await response.json();
                this.isOnline = true;
                
                if (this.offlineOperations.length > 0) {
                    this.updateStatus('online', 'Połączenie aktywne', `${this.offlineOperations.length} operacji do synchronizacji`);
                    this.syncButton.style.display = 'inline-block';
                } else {
                    this.updateStatus('online', 'Połączenie aktywne', 'Wszystkie dane zsynchronizowane');
                    this.hideIndicator(3000); // Hide after 3 seconds
                }
            } else {
                throw new Error('Network check failed');
            }
        } catch (error) {
            this.isOnline = false;
            this.updateStatus('offline', 'Brak połączenia', 'Sprawdź połączenie internetowe');
            this.retryButton.style.display = 'inline-block';
        }
    }
    
    async syncOfflineData() {
        if (!this.isOnline || this.offlineOperations.length === 0) {
            return;
        }
        
        this.updateStatus('checking', 'Synchronizacja...', 'Wysyłanie danych na serwer');
        this.syncButton.style.display = 'none';
        
        try {
            const response = await fetch('/api/sync/offline-data/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': this.getCSRFToken()
                },
                body: JSON.stringify({
                    operations: this.offlineOperations
                })
            });
            
            if (response.ok) {
                const result = await response.json();
                
                if (result.success) {
                    this.offlineOperations = result.remaining_operations || [];
                    this.updateOfflineQueue();
                    
                    if (this.offlineOperations.length === 0) {
                        this.updateStatus('online', 'Synchronizacja zakończona', 'Wszystkie dane zostały zsynchronizowane');
                        this.hideIndicator(3000);
                    } else {
                        this.updateStatus('online', 'Synchronizacja częściowa', `${this.offlineOperations.length} operacji wymaga ponownej próby`);
                        this.syncButton.style.display = 'inline-block';
                    }
                } else {
                    throw new Error(result.message || 'Synchronization failed');
                }
            } else {
                throw new Error('Sync request failed');
            }
        } catch (error) {
            this.updateStatus('offline', 'Błąd synchronizacji', error.message);
            this.syncButton.style.display = 'inline-block';
        }
    }
    
    updateStatus(type, message, details) {
        // Update icon
        this.statusIcon.className = `fas ${this.getIconClass(type)}`;
        this.statusIcon.parentElement.className = `status-icon ${type}`;
        
        // Update text
        this.statusMessage.textContent = message;
        this.statusDetails.textContent = details;
        
        // Show/hide buttons
        this.retryButton.style.display = type === 'offline' ? 'inline-block' : 'none';
        this.syncButton.style.display = (type === 'online' && this.offlineOperations.length > 0) ? 'inline-block' : 'none';
        
        // Show indicator for offline or error states
        if (type === 'offline' || type === 'checking') {
            this.showIndicator();
        }
    }
    
    getIconClass(type) {
        switch (type) {
            case 'online': return 'fa-wifi';
            case 'offline': return 'fa-wifi-slash';
            case 'checking': return 'fa-spinner';
            default: return 'fa-wifi';
        }
    }
    
    showIndicator() {
        this.indicator.style.display = 'block';
        this.updateOfflineQueue();
    }
    
    hideIndicator(delay = 0) {
        setTimeout(() => {
            if (this.isOnline && this.offlineOperations.length === 0) {
                this.indicator.style.display = 'none';
            }
        }, delay);
    }
    
    updateOfflineQueue() {
        if (this.offlineOperations.length > 0) {
            this.offlineQueue.style.display = 'block';
            this.queueList.innerHTML = '';
            
            this.offlineOperations.forEach(operation => {
                const item = document.createElement('div');
                item.className = 'queue-item';
                item.innerHTML = `
                    <div class="queue-item-info">
                        <div class="queue-item-operation">${this.getOperationDisplayName(operation.operation)}</div>
                        <div class="queue-item-time">${this.formatTime(operation.timestamp)}</div>
                    </div>
                    <div class="queue-item-status ${operation.status || 'pending'}">${this.getStatusDisplayName(operation.status || 'pending')}</div>
                `;
                this.queueList.appendChild(item);
            });
        } else {
            this.offlineQueue.style.display = 'none';
        }
    }
    
    getOperationDisplayName(operation) {
        const names = {
            'create_invoice': 'Nowa faktura',
            'update_invoice': 'Aktualizacja faktury',
            'create_contractor': 'Nowy kontrahent',
            'update_contractor': 'Aktualizacja kontrahenta',
            'create_product': 'Nowy produkt',
            'update_product': 'Aktualizacja produktu'
        };
        return names[operation] || operation;
    }
    
    getStatusDisplayName(status) {
        const names = {
            'pending': 'Oczekuje',
            'syncing': 'Synchronizacja',
            'failed': 'Błąd'
        };
        return names[status] || status;
    }
    
    formatTime(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleString('pl-PL', {
            hour: '2-digit',
            minute: '2-digit',
            day: '2-digit',
            month: '2-digit'
        });
    }
    
    loadOfflineOperations() {
        // Load from localStorage or make API call
        const stored = localStorage.getItem('offlineOperations');
        if (stored) {
            this.offlineOperations = JSON.parse(stored);
            this.updateOfflineQueue();
        }
        
        // Also check server for any pending operations
        this.fetchOfflineOperations();
    }
    
    async fetchOfflineOperations() {
        try {
            const response = await fetch('/api/sync/status/');
            if (response.ok) {
                const data = await response.json();
                this.offlineOperations = data.operations || [];
                this.updateOfflineQueue();
                
                // Update localStorage
                localStorage.setItem('offlineOperations', JSON.stringify(this.offlineOperations));
            }
        } catch (error) {
            console.warn('Failed to fetch offline operations:', error);
        }
    }
    
    startPeriodicChecks() {
        // Check connection every 30 seconds
        this.checkInterval = setInterval(() => {
            if (!this.isOnline) {
                this.checkConnection();
            }
        }, 30000);
        
        // Try to sync every 60 seconds if online and have pending operations
        this.syncInterval = setInterval(() => {
            if (this.isOnline && this.offlineOperations.length > 0) {
                this.syncOfflineData();
            }
        }, 60000);
    }
    
    getCSRFToken() {
        const cookies = document.cookie.split(';');
        for (let cookie of cookies) {
            const [name, value] = cookie.trim().split('=');
            if (name === 'csrftoken') {
                return value;
            }
        }
        return '';
    }
    
    destroy() {
        if (this.checkInterval) {
            clearInterval(this.checkInterval);
        }
        if (this.syncInterval) {
            clearInterval(this.syncInterval);
        }
        
        window.removeEventListener('online', this.handleOnline);
        window.removeEventListener('offline', this.handleOffline);
    }
}

// Initialize network status indicator when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
    window.networkStatusIndicator = new NetworkStatusIndicator();
});

// Cleanup on page unload
window.addEventListener('beforeunload', function() {
    if (window.networkStatusIndicator) {
        window.networkStatusIndicator.destroy();
    }
});
</script>
(function () {'use strict'; const chartState = {initialized: false, charts: new Map(), config: {defaultOptions: {chart: {fontFamily: 'Inter, sans-serif', toolbar: {show: false }, animations: {enabled: true, easing: 'easeinout', speed: 800 }}, colors: ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6'], dataLabels: {enabled: false }, stroke: {curve: 'smooth', width: 2 }, grid: {borderColor: '#E5E7EB', strokeDashArray: 4 }, tooltip: {theme: 'light', style: {fontSize: '12px' }}}}}; const utils = {log: function (message, type = 'info') {if (console && console[type]) {console[type]('[Charts Manager]', message)}}, mergeOptions: function (defaultOptions, customOptions) {return Object.assign({}, defaultOptions, customOptions)}, formatNumber: function (num) {if (num >= 1000000) {return (num / 1000000).toFixed(1) + 'M'}else if (num >= 1000) {return (num / 1000).toFixed(1) + 'K'}return num.toString()}, getChartContainer: function (selector) {const container = document.querySelector(selector); if (!container) {utils.log(`Chart container not found: ${selector}`, 'warn'); return null}return container}, createFallbackChart: function (container, data) {container.innerHTML = ` <div class="chart-fallback" style=" display: flex; flex-direction: column; align-items: center; justify-content: center; height: 200px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; color: #6c757d; "> <div style="font-size: 24px; font-weight: bold; margin-bottom: 8px;"> ${data.value || 'N/A'}</div> <div style="font-size: 14px;"> ${data.title || 'Chart Data'}</div> <div style="font-size: 12px; margin-top: 4px; opacity: 0.7;"> Chart visualization unavailable </div> </div> `}}; const chartCreators = {createAreaChart: function (selector, options) {const container = utils.getChartContainer(selector); if (!container) return null; const defaultOptions = {chart: {type: 'area', height: 300 }, fill: {type: 'gradient', gradient: {shadeIntensity: 1, opacityFrom: 0.7, opacityTo: 0.3, stops: [0, 90, 100] }}}; const chartOptions = utils.mergeOptions(utils.mergeOptions(chartState.config.defaultOptions, defaultOptions), options); try {const chart = new ApexCharts(container, chartOptions); chart.render(); chartState.charts.set(selector, chart); utils.log(`Area chart created: ${selector}`); return chart}catch (error) {utils.log(`Failed to create area chart: ${error.message}`, 'error'); utils.createFallbackChart(container, {title: 'Area Chart', value: options.series?.[0]?.data?.length || 0 }); return null}}, createBarChart: function (selector, options) {const container = utils.getChartContainer(selector); if (!container) return null; const defaultOptions = {chart: {type: 'bar', height: 300 }, plotOptions: {bar: {borderRadius: 4, horizontal: false }}}; const chartOptions = utils.mergeOptions(utils.mergeOptions(chartState.config.defaultOptions, defaultOptions), options); try {const chart = new ApexCharts(container, chartOptions); chart.render(); chartState.charts.set(selector, chart); utils.log(`Bar chart created: ${selector}`); return chart}catch (error) {utils.log(`Failed to create bar chart: ${error.message}`, 'error'); utils.createFallbackChart(container, {title: 'Bar Chart', value: options.series?.[0]?.data?.length || 0 }); return null}}, createLineChart: function (selector, options) {const container = utils.getChartContainer(selector); if (!container) return null; const defaultOptions = {chart: {type: 'line', height: 300 }, markers: {size: 4, strokeWidth: 2, hover: {size: 6 }}}; const chartOptions = utils.mergeOptions(utils.mergeOptions(chartState.config.defaultOptions, defaultOptions), options); try {const chart = new ApexCharts(container, chartOptions); chart.render(); chartState.charts.set(selector, chart); utils.log(`Line chart created: ${selector}`); return chart}catch (error) {utils.log(`Failed to create line chart: ${error.message}`, 'error'); utils.createFallbackChart(container, {title: 'Line Chart', value: options.series?.[0]?.data?.length || 0 }); return null}}, createDonutChart: function (selector, options) {const container = utils.getChartContainer(selector); if (!container) return null; const defaultOptions = {chart: {type: 'donut', height: 300 }, plotOptions: {pie: {donut: {size: '70%' }}}, legend: {position: 'bottom' }}; const chartOptions = utils.mergeOptions(utils.mergeOptions(chartState.config.defaultOptions, defaultOptions), options); try {const chart = new ApexCharts(container, chartOptions); chart.render(); chartState.charts.set(selector, chart); utils.log(`Donut chart created: ${selector}`); return chart}catch (error) {utils.log(`Failed to create donut chart: ${error.message}`, 'error'); utils.createFallbackChart(container, {title: 'Donut Chart', value: options.series?.reduce((a, b) => a + b, 0) || 0 }); return null}}}; const dashboardCharts = {initializeRevenueChart: function () {const selector = '#revenueChart'; const container = document.querySelector(selector); if (!container) return; const chartData = this.getChartData(container) || {series: [{name: 'Revenue', data: [30, 40, 35, 50, 49, 60, 70, 91, 125, 100, 85, 95] }], categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }; return chartCreators.createAreaChart(selector, {series: chartData.series, xaxis: {categories: chartData.categories }, title: {text: 'Monthly Revenue', align: 'left' }, yaxis: {labels: {formatter: function (val) {return utils.formatNumber(val)}}}})}, initializeInvoiceStatusChart: function () {const selector = '#invoiceStatusChart'; const container = document.querySelector(selector); if (!container) return; const chartData = this.getChartData(container) || {series: [44, 55, 13, 33], labels: ['Paid', 'Pending', 'Overdue', 'Draft'] }; return chartCreators.createDonutChart(selector, {series: chartData.series, labels: chartData.labels, title: {text: 'Invoice Status Distribution', align: 'left' }})}, initializeMonthlyInvoicesChart: function () {const selector = '#monthlyInvoicesChart'; const container = document.querySelector(selector); if (!container) return; const chartData = this.getChartData(container) || {series: [{name: 'Invoices Created', data: [10, 15, 12, 18, 22, 25, 30, 28, 35, 32, 40, 45] }], categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }; return chartCreators.createBarChart(selector, {series: chartData.series, xaxis: {categories: chartData.categories }, title: {text: 'Monthly Invoice Count', align: 'left' }})}, initializeOCRProcessingChart: function () {const selector = '#ocrProcessingChart'; const container = document.querySelector(selector); if (!container) return; const chartData = this.getChartData(container) || {series: [{name: 'Documents Processed', data: [5, 8, 12, 15, 18, 22, 25, 30, 28, 35, 32, 40] }], categories: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'] }; return chartCreators.createLineChart(selector, {series: chartData.series, xaxis: {categories: chartData.categories }, title: {text: 'OCR Processing Volume', align: 'left' }})}, getChartData: function (container) {try {const dataAttr = container.getAttribute('data-chart'); if (dataAttr) {return JSON.parse(dataAttr)}}catch (error) {utils.log(`Failed to parse chart data: ${error.message}`, 'warn')}return null}}; const chartsManager = {init: function () {utils.log('Initializing charts manager'); if (typeof ApexCharts === 'undefined') {utils.log('ApexCharts not available, waiting for dependency manager', 'warn'); this.waitForApexCharts(); return}this.initializeAllCharts()}, waitForApexCharts: function () {document.addEventListener('apexcharts:ready', () => {utils.log('ApexCharts ready event received'); this.initializeAllCharts()}); if (window.DependencyManager) {window.DependencyManager.whenReady('ApexCharts', (error) => {if (error) {utils.log(`ApexCharts failed to load: ${error.message}`, 'error'); this.createFallbackDashboard()}else {utils.log('ApexCharts loaded via DependencyManager'); this.initializeAllCharts()}})}setTimeout(() => {if (!chartState.initialized && typeof ApexCharts === 'undefined') {utils.log('ApexCharts loading timeout, creating fallbacks', 'warn'); this.createFallbackDashboard()}}, 5000)}, initializeAllCharts: function () {if (chartState.initialized) {utils.log('Charts already initialized'); return}utils.log('Initializing all dashboard charts'); try {dashboardCharts.initializeRevenueChart(); dashboardCharts.initializeInvoiceStatusChart(); dashboardCharts.initializeMonthlyInvoicesChart(); dashboardCharts.initializeOCRProcessingChart(); chartState.initialized = true; utils.log('All charts initialized successfully'); document.dispatchEvent(new CustomEvent('charts:initialized'))}catch (error) {utils.log(`Chart initialization failed: ${error.message}`, 'error'); this.createFallbackDashboard()}}, createFallbackDashboard: function () {utils.log('Creating fallback dashboard'); const chartSelectors = ['#revenueChart', '#invoiceStatusChart', '#monthlyInvoicesChart', '#ocrProcessingChart']; chartSelectors.forEach(selector => {const container = document.querySelector(selector); if (container) {utils.createFallbackChart(container, {title: 'Dashboard Chart', value: 'Data Available' })}}); chartState.initialized = true}, updateChart: function (selector, newData) {const chart = chartState.charts.get(selector); if (chart) {try {chart.updateSeries(newData.series); utils.log(`Chart updated: ${selector}`)}catch (error) {utils.log(`Failed to update chart ${selector}: ${error.message}`, 'error')}}}, destroyChart: function (selector) {const chart = chartState.charts.get(selector); if (chart) {try {chart.destroy(); chartState.charts.delete(selector); utils.log(`Chart destroyed: ${selector}`)}catch (error) {utils.log(`Failed to destroy chart ${selector}: ${error.message}`, 'error')}}}, destroyAllCharts: function () {chartState.charts.forEach((chart, selector) => {this.destroyChart(selector)}); chartState.initialized = false}}; if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', () => {chartsManager.init()})}else {chartsManager.init()}window.ChartsManager = {init: chartsManager.init.bind(chartsManager), updateChart: chartsManager.updateChart.bind(chartsManager), destroyChart: chartsManager.destroyChart.bind(chartsManager), destroyAllCharts: chartsManager.destroyAllCharts.bind(chartsManager), createChart: function (type, selector, options) {if (chartCreators[`create${type}Chart`]) {return chartCreators[`create${type}Chart`](selector, options)}else {utils.log(`Unknown chart type: ${type}`, 'error'); return null}}}})();
(function() {'use strict'; const DEPENDENCIES = {core: [{name: 'jQuery', src: 'assets/js/lib/jquery-3.7.1.min.js', test: function() {return typeof jQuery !== 'undefined' && typeof $ !== 'undefined'}, fallback: 'https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js', critical: true, global: 'jQuery' }], ui: [{name: 'Bootstrap', src: 'assets/js/lib/bootstrap.bundle.min.js', test: function() {return typeof bootstrap !== 'undefined'}, fallback: 'https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js', critical: true, dependencies: ['jQuery'] }], charts: [{name: 'ApexCharts', src: 'assets/js/lib/apexcharts.min.js', test: function() {return typeof ApexCharts !== 'undefined'}, fallback: 'https://cdn.jsdelivr.net/npm/apexcharts@latest/dist/apexcharts.min.js', critical: true }], tables: [{name: 'DataTables', src: 'assets/js/lib/dataTables.min.js', test: function() {return typeof $.fn.DataTable !== 'undefined'}, fallback: 'https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js', critical: false, dependencies: ['jQuery'] }], optional: [{name: 'jQuery UI', src: 'assets/js/lib/jquery-ui.min.js', test: function() {return typeof $.ui !== 'undefined'}, fallback: 'https://cdnjs.cloudflare.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js', critical: false, dependencies: ['jQuery'] }, {name: 'Magnific Popup', src: 'assets/js/lib/magnific-popup.min.js', test: function() {return typeof $.fn.magnificPopup !== 'undefined'}, fallback: 'https://cdnjs.cloudflare.com/ajax/libs/magnific-popup.js/1.1.0/jquery.magnific-popup.min.js', critical: false, dependencies: ['jQuery'] }, {name: 'Slick Slider', src: 'assets/js/lib/slick.min.js', test: function() {return typeof $.fn.slick !== 'undefined'}, fallback: 'https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js', critical: false, dependencies: ['jQuery'] }, {name: 'Iconify', src: 'assets/js/lib/iconify-icon.min.js', test: function() {return typeof Iconify !== 'undefined'}, fallback: 'https://code.iconify.design/3/3.1.1/iconify.min.js', critical: false }, {name: 'Prism', src: 'assets/js/lib/prism.js', test: function() {return typeof Prism !== 'undefined'}, fallback: 'https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js', critical: false }] }; const loadingState = {loaded: new Set(), failed: new Set(), loading: new Set(), callbacks: new Map() }; const utils = {log: function(message, type = 'info') {if (console && console[type]) {console[type]('[Dependency Manager]', message)}}, getStaticUrl: function(path) {const staticUrl = window.STATIC_URL || '/static/'; return staticUrl + path}, createScript: function(src, integrity = null) {const script = document.createElement('script'); script.src = src; script.async = false; if (integrity) {script.integrity = integrity; script.crossOrigin = 'anonymous'}return script}, waitForDependencies: function(dependencies) {if (!dependencies || dependencies.length === 0) {return Promise.resolve()}const promises = dependencies.map(depName => {return new Promise((resolve, reject) => {if (loadingState.loaded.has(depName)) {resolve(); return}if (loadingState.failed.has(depName)) {reject(new Error(`Dependency ${depName}failed to load`)); return}const checkInterval = setInterval(() => {if (loadingState.loaded.has(depName)) {clearInterval(checkInterval); resolve()}else if (loadingState.failed.has(depName)) {clearInterval(checkInterval); reject(new Error(`Dependency ${depName}failed to load`))}}, 50); setTimeout(() => {clearInterval(checkInterval); reject(new Error(`Timeout waiting for dependency ${depName}`))}, 10000)})}); return Promise.all(promises)}}; const scriptLoader = {loadScript: function(dependency) {return new Promise((resolve, reject) => {const {name, src, test, fallback, critical }= dependency; if (test && test()) {utils.log(`${name}already available`); loadingState.loaded.add(name); resolve(); return}if (loadingState.loading.has(name)) {utils.log(`${name}already loading, waiting...`); this.waitForLoad(name).then(resolve).catch(reject); return}loadingState.loading.add(name); const fullSrc = utils.getStaticUrl(src); utils.log(`Loading ${name}from ${fullSrc}`); const script = utils.createScript(fullSrc); script.onload = () => {loadingState.loading.delete(name); if (test && !test()) {utils.log(`${name}loaded but test failed, trying fallback`, 'warn'); this.loadFallback(dependency).then(resolve).catch(reject); return}utils.log(`${name}loaded successfully`); loadingState.loaded.add(name); this.triggerCallbacks(name, null); resolve()}; script.onerror = () => {loadingState.loading.delete(name); utils.log(`${name}failed to load from ${fullSrc}, trying fallback`, 'warn'); this.loadFallback(dependency).then(resolve).catch(reject)}; document.head.appendChild(script)})}, loadFallback: function(dependency) {return new Promise((resolve, reject) => {const {name, test, fallback, critical }= dependency; if (!fallback) {const error = new Error(`No fallback available for ${name}`); loadingState.failed.add(name); this.triggerCallbacks(name, error); if (critical) {this.handleCriticalFailure(name)}reject(error); return}utils.log(`Loading ${name}from fallback: ${fallback}`); const script = utils.createScript(fallback); script.onload = () => {if (test && !test()) {const error = new Error(`${name}fallback loaded but test failed`); loadingState.failed.add(name); this.triggerCallbacks(name, error); if (critical) {this.handleCriticalFailure(name)}reject(error); return}utils.log(`${name}loaded successfully from fallback`); loadingState.loaded.add(name); this.triggerCallbacks(name, null); resolve()}; script.onerror = () => {const error = new Error(`${name}fallback also failed`); loadingState.failed.add(name); this.triggerCallbacks(name, error); if (critical) {this.handleCriticalFailure(name)}reject(error)}; document.head.appendChild(script)})}, waitForLoad: function(name) {return new Promise((resolve, reject) => {const checkInterval = setInterval(() => {if (loadingState.loaded.has(name)) {clearInterval(checkInterval); resolve()}else if (loadingState.failed.has(name)) {clearInterval(checkInterval); reject(new Error(`${name}failed to load`))}}, 50); setTimeout(() => {clearInterval(checkInterval); reject(new Error(`Timeout waiting for ${name}`))}, 10000)})}, handleCriticalFailure: function(name) {utils.log(`Critical dependency ${name}failed to load`, 'error'); const notification = document.createElement('div'); notification.className = 'dependency-failure-notification'; notification.style.cssText = ` position: fixed; top: 20px; right: 20px; background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; border-radius: 4px; padding: 12px 16px; z-index: 9999; max-width: 300px; font-size: 14px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); `; notification.innerHTML = ` <strong>Loading Error</strong><br> ${name}failed to load. Some features may not work properly. <button onclick="this.parentNode.remove()" style="float: right; background: none; border: none; font-size: 16px; cursor: pointer;">&times;</button> `; document.body.appendChild(notification); setTimeout(() => {if (notification.parentNode) {notification.parentNode.removeChild(notification)}}, 10000)}, triggerCallbacks: function(name, error) {const callbacks = loadingState.callbacks.get(name); if (callbacks) {callbacks.forEach(callback => {try {callback(error)}catch (e) {utils.log(`Callback error for ${name}: ${e.message}`, 'error')}}); loadingState.callbacks.delete(name)}}}; const dependencyManager = {init: function() {utils.log('Initializing dependency manager'); this.loadDependencies()}, loadDependencies: function() {const loadOrder = ['core', 'ui', 'charts', 'tables', 'optional']; let loadPromise = Promise.resolve(); loadOrder.forEach(category => {loadPromise = loadPromise.then(() => {return this.loadCategory(category)})}); loadPromise .then(() => {utils.log('All dependencies loaded successfully'); this.reportStatus(); this.initializeComponents()}) .catch(error => {utils.log(`Dependency loading failed: ${error.message}`, 'error'); this.reportStatus()})}, loadCategory: function(category) {const dependencies = DEPENDENCIES[category]; if (!dependencies) {return Promise.resolve()}utils.log(`Loading ${category}dependencies`); const promises = dependencies.map(dependency => {return utils.waitForDependencies(dependency.dependencies || []) .then(() => scriptLoader.loadScript(dependency))}); return Promise.all(promises)}, reportStatus: function() {utils.log('Dependency loading report:'); utils.log(`Loaded: ${Array.from(loadingState.loaded).join(', ')}`); if (loadingState.failed.size > 0) {utils.log(`Failed: ${Array.from(loadingState.failed).join(', ')}`, 'warn')}window.dependencyStatus = {loaded: Array.from(loadingState.loaded), failed: Array.from(loadingState.failed), loading: Array.from(loadingState.loading) }}, initializeComponents: function() {if (loadingState.loaded.has('jQuery')) {this.initializeJQueryComponents()}if (loadingState.loaded.has('ApexCharts')) {this.initializeCharts()}if (loadingState.loaded.has('DataTables')) {this.initializeDataTables()}}, initializeJQueryComponents: function() {utils.log('Initializing jQuery components'); if (typeof $ === 'undefined' && typeof jQuery !== 'undefined') {window.$ = jQuery}if (typeof $ !== 'undefined') {$(document).trigger('jquery:ready')}}, initializeCharts: function() {utils.log('ApexCharts available for initialization'); document.dispatchEvent(new CustomEvent('apexcharts:ready'))}, initializeDataTables: function() {utils.log('DataTables available for initialization'); document.dispatchEvent(new CustomEvent('datatables:ready'))}, whenReady: function(dependencyName, callback) {if (loadingState.loaded.has(dependencyName)) {callback(null); return}if (loadingState.failed.has(dependencyName)) {callback(new Error(`${dependencyName}failed to load`)); return}if (!loadingState.callbacks.has(dependencyName)) {loadingState.callbacks.set(dependencyName, [])}loadingState.callbacks.get(dependencyName).push(callback)}, isLoaded: function(dependencyName) {return loadingState.loaded.has(dependencyName)}, hasFailed: function(dependencyName) {return loadingState.failed.has(dependencyName)}}; if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', () => {dependencyManager.init()})}else {dependencyManager.init()}window.DependencyManager = {whenReady: dependencyManager.whenReady.bind(dependencyManager), isLoaded: dependencyManager.isLoaded.bind(dependencyManager), hasFailed: dependencyManager.hasFailed.bind(dependencyManager), getStatus: function() {return {loaded: Array.from(loadingState.loaded), failed: Array.from(loadingState.failed), loading: Array.from(loadingState.loading) }}}})();
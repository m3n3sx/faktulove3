class NetworkMonitor {constructor() {this.isOnline = navigator.onLine; this.connectionQuality = 'unknown'; this.statusIndicator = null; this.retryQueue = []; this.isInitialized = false; this.config = {showStatusIndicator: true, retryAttempts: 3, retryDelay: 2000, pingInterval: 30000, pingUrl: '/api/ping/', qualityThresholds: {excellent: 100, good: 300, fair: 1000, poor: 3000 }}; this.init()}init() {if (this.isInitialized) return; this.setupEventListeners(); this.createStatusIndicator(); this.startConnectionMonitoring(); this.updateStatus(); this.isInitialized = true; this.log('NetworkMonitor initialized')}setupEventListeners() {window.addEventListener('online', () => {this.handleOnline()}); window.addEventListener('offline', () => {this.handleOffline()}); document.addEventListener('visibilitychange', () => {if (!document.hidden && this.isOnline) {this.checkConnection()}})}createStatusIndicator() {if (!this.config.showStatusIndicator) return; this.statusIndicator = document.createElement('div'); this.statusIndicator.id = 'network-status'; this.statusIndicator.className = 'network-status'; this.statusIndicator.style.cssText = ` position: fixed; bottom: 20px; left: 20px; padding: 8px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; z-index: 1000; transition: all 0.3s ease; cursor: pointer; `; this.statusIndicator.addEventListener('click', () => {this.checkConnection()}); document.body.appendChild(this.statusIndicator)}startConnectionMonitoring() {this.checkConnection(); setInterval(() => {if (this.isOnline) {this.checkConnectionQuality()}}, this.config.pingInterval)}handleOnline() {this.isOnline = true; this.log('Network connection restored'); this.updateStatus(); this.processRetryQueue(); if (window.ErrorHandler) {window.ErrorHandler.showUserNotification('Network connection restored', 'success')}this.checkConnectionQuality()}handleOffline() {this.isOnline = false; this.connectionQuality = 'offline'; this.log('Network connection lost'); this.updateStatus(); if (window.ErrorHandler) {window.ErrorHandler.showUserNotification('Network connection lost. Some features may not work.', 'warning')}}async checkConnection() {try {const startTime = performance.now(); const response = await fetch(this.config.pingUrl, {method: 'HEAD', cache: 'no-cache', timeout: 5000 }); const endTime = performance.now(); const latency = endTime - startTime; if (response.ok) {this.isOnline = true; this.updateConnectionQuality(latency)}else {this.isOnline = false; this.connectionQuality = 'error'}}catch (error) {this.isOnline = false; this.connectionQuality = 'offline'; this.log('Connection check failed:', error)}this.updateStatus()}async checkConnectionQuality() {if (!this.isOnline) return; try {const startTime = performance.now(); const response = await fetch(this.config.pingUrl, {method: 'HEAD', cache: 'no-cache' }); const endTime = performance.now(); const latency = endTime - startTime; if (response.ok) {this.updateConnectionQuality(latency)}}catch (error) {this.connectionQuality = 'poor'; this.log('Connection quality check failed:', error)}this.updateStatus()}updateConnectionQuality(latency) {const thresholds = this.config.qualityThresholds; if (latency <= thresholds.excellent) {this.connectionQuality = 'excellent'}else if (latency <= thresholds.good) {this.connectionQuality = 'good'}else if (latency <= thresholds.fair) {this.connectionQuality = 'fair'}else {this.connectionQuality = 'poor'}this.log(`Connection quality: ${this.connectionQuality}(${Math.round(latency)}ms)`)}updateStatus() {if (!this.statusIndicator) return; const status = this.getStatusInfo(); this.statusIndicator.textContent = status.text; this.statusIndicator.className = `network-status ${status.class}`; this.statusIndicator.title = status.tooltip; document.body.classList.toggle('network-online', this.isOnline); document.body.classList.toggle('network-offline', !this.isOnline); document.body.classList.remove('connection-excellent', 'connection-good', 'connection-fair', 'connection-poor'); if (this.isOnline) {document.body.classList.add(`connection-${this.connectionQuality}`)}}getStatusInfo() {if (!this.isOnline) {return {text: 'ðŸ”´ Offline', class: 'offline', tooltip: 'No network connection. Click to retry.' }}const qualityIcons = {excellent: 'ðŸŸ¢', good: 'ðŸŸ¡', fair: 'ðŸŸ ', poor: 'ðŸ”´', unknown: 'âšª' }; const qualityLabels = {excellent: 'Excellent', good: 'Good', fair: 'Fair', poor: 'Poor', unknown: 'Unknown' }; return {text: `${qualityIcons[this.connectionQuality]}${qualityLabels[this.connectionQuality]}`, class: 'online', tooltip: `Network connection: ${qualityLabels[this.connectionQuality]}. Click to refresh.` }}addToRetryQueue(requestInfo) {this.retryQueue.push({...requestInfo, attempts: 0, timestamp: Date.now() }); this.log(`Added request to retry queue: ${requestInfo.url}`)}async processRetryQueue() {if (!this.isOnline || this.retryQueue.length === 0) return; this.log(`Processing retry queue: ${this.retryQueue.length}requests`); const queue = [...this.retryQueue]; this.retryQueue = []; for (const request of queue) {try {await this.retryRequest(request)}catch (error) {this.log(`Retry failed for ${request.url}:`, error); if (request.attempts < this.config.retryAttempts) {request.attempts++; this.retryQueue.push(request)}}}}async retryRequest(request) {const {url, options, callback }= request; if (request.attempts > 0) {await this.delay(this.config.retryDelay * request.attempts)}const response = await fetch(url, options); if (response.ok && callback) {callback(response)}return response}delay(ms) {return new Promise(resolve => setTimeout(resolve, ms))}monitoredFetch(url, options = {}) {return fetch(url, options) .then(response => {if (!this.isOnline && response.ok) {this.handleOnline()}return response}) .catch(error => {if (error.name === 'TypeError' && error.message.includes('fetch')) {this.handleOffline(); this.addToRetryQueue({url, options, callback: null })}throw error})}getStatus() {return {isOnline: this.isOnline, connectionQuality: this.connectionQuality, retryQueueLength: this.retryQueue.length, lastCheck: new Date().toISOString() }}forceCheck() {this.log('Forcing connection check...'); this.checkConnection()}clearRetryQueue() {this.retryQueue = []; this.log('Retry queue cleared')}log(message, ...args) {console.log(`[NetworkMonitor] ${message}`, ...args)}destroy() {if (this.statusIndicator) {this.statusIndicator.remove()}this.isInitialized = false; this.log('NetworkMonitor destroyed')}}window.NetworkMonitor = new NetworkMonitor(); if (window.fetch && window.NetworkMonitor) {const originalFetch = window.fetch; window.fetch = function(...args) {return window.NetworkMonitor.monitoredFetch(...args)}}if (typeof module !== 'undefined' && module.exports) {module.exports = NetworkMonitor}
(function(window) {'use strict'; class OCRHandler {constructor() {this.uploadInProgress = false; this.statusCheckInterval = null; this.maxStatusChecks = 120; this.statusCheckCount = 0; this.init()}init() {this.bindEvents(); this.setupProgressIndicators()}bindEvents() {const uploadForms = document.querySelectorAll('.ocr-upload-form'); uploadForms.forEach(form => {form.addEventListener('submit', (e) => this.handleUploadSubmit(e))}); const fileInputs = document.querySelectorAll('.ocr-file-input'); fileInputs.forEach(input => {input.addEventListener('change', (e) => this.handleFileSelect(e))}); const dropZones = document.querySelectorAll('.ocr-drop-zone'); dropZones.forEach(zone => {zone.addEventListener('dragover', (e) => this.handleDragOver(e)); zone.addEventListener('drop', (e) => this.handleDrop(e)); zone.addEventListener('dragleave', (e) => this.handleDragLeave(e))}); const refreshButtons = document.querySelectorAll('.ocr-status-refresh'); refreshButtons.forEach(button => {button.addEventListener('click', (e) => this.handleStatusRefresh(e))}); const validationForms = document.querySelectorAll('.ocr-validation-form'); validationForms.forEach(form => {form.addEventListener('submit', (e) => this.handleValidationSubmit(e))})}setupProgressIndicators() {if (!document.querySelector('.ocr-progress-template')) {const template = document.createElement('div'); template.className = 'ocr-progress-template d-none'; template.innerHTML = ` <div class="progress mb-3"> <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"> <span class="progress-text">Przygotowywanie...</span> </div> </div> <div class="ocr-status-text text-muted"> <small>Oczekiwanie na rozpoczęcie przetwarzania...</small> </div> `; document.body.appendChild(template)}}async handleUploadSubmit(event) {event.preventDefault(); if (this.uploadInProgress) {this.showMessage('Upload już w toku. Proszę czekać.', 'warning'); return}const form = event.target; const fileInput = form.querySelector('input[type="file"]'); const file = fileInput.files[0]; if (!file) {this.showMessage('Proszę wybrać plik do przesłania.', 'error'); return}if (!this.validateFile(file)) {return}try {this.uploadInProgress = true; this.showUploadProgress(form); const result = await OCRAJAXHelper.uploadDocument(file, (progress) => {this.updateUploadProgress(progress)}); this.showMessage('Plik został przesłany pomyślnie!', 'success'); this.handleUploadSuccess(result)}catch (error) {console.error('Upload failed:', error); this.showMessage(`Błąd podczas przesyłania: ${error.message}`, 'error'); this.hideUploadProgress()}finally {this.uploadInProgress = false}}handleFileSelect(event) {const file = event.target.files[0]; if (file) {this.displayFileInfo(file, event.target)}}handleDragOver(event) {event.preventDefault(); event.currentTarget.classList.add('drag-over')}handleDragLeave(event) {event.currentTarget.classList.remove('drag-over')}handleDrop(event) {event.preventDefault(); event.currentTarget.classList.remove('drag-over'); const files = event.dataTransfer.files; if (files.length > 0) {const file = files[0]; const fileInput = event.currentTarget.querySelector('input[type="file"]'); if (fileInput) {const dt = new DataTransfer(); dt.items.add(file); fileInput.files = dt.files; this.displayFileInfo(file, fileInput)}}}async handleStatusRefresh(event) {event.preventDefault(); const button = event.currentTarget; const taskId = button.dataset.taskId; const documentId = button.dataset.documentId; if (!taskId && !documentId) {this.showMessage('Brak identyfikatora zadania lub dokumentu.', 'error'); return}try {button.disabled = true; button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sprawdzanie...'; let result; if (taskId) {result = await OCRAJAXHelper.checkStatus(taskId)}else {result = await AJAXHelper.request(`/api/v1/ocr/document/${documentId}/status/`)}this.updateStatusDisplay(result, button.closest('.ocr-status-container'))}catch (error) {console.error('Status check failed:', error); this.showMessage(`Błąd podczas sprawdzania statusu: ${error.message}`, 'error')}finally {button.disabled = false; button.innerHTML = '<i class="fas fa-refresh"></i> Odśwież'}}async handleValidationSubmit(event) {event.preventDefault(); const form = event.target; const resultId = form.dataset.resultId; if (!resultId) {this.showMessage('Brak identyfikatora wyniku OCR.', 'error'); return}try {const formData = new FormData(form); const corrections = {}; for (let [key, value] of formData.entries()) {if (key !== 'csrfmiddlewaretoken') {corrections[key] = value}}const submitButton = form.querySelector('button[type="submit"]'); submitButton.disabled = true; submitButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Zapisywanie...'; const result = await OCRAJAXHelper.submitValidation(resultId, corrections); this.showMessage('Korekty zostały zapisane pomyślnie!', 'success'); if (result.data && result.data.invoice_id) {setTimeout(() => {window.location.href = `/faktury/${result.data.invoice_id}/`}, 2000)}}catch (error) {console.error('Validation submission failed:', error); this.showMessage(`Błąd podczas zapisywania: ${error.message}`, 'error')}finally {const submitButton = form.querySelector('button[type="submit"]'); submitButton.disabled = false; submitButton.innerHTML = 'Zapisz korekty'}}validateFile(file) {const maxSize = 10 * 1024 * 1024; const allowedTypes = ['application/pdf', 'image/jpeg', 'image/png', 'image/tiff', 'image/gif']; if (file.size > maxSize) {this.showMessage(`Plik jest za duży. Maksymalny rozmiar to ${maxSize / 1024 / 1024}MB.`, 'error'); return false}if (!allowedTypes.includes(file.type)) {this.showMessage('Nieobsługiwany typ pliku. Dozwolone: PDF, JPEG, PNG, TIFF, GIF.', 'error'); return false}return true}displayFileInfo(file, input) {const container = input.closest('.file-upload-container') || input.parentElement; let infoDiv = container.querySelector('.file-info'); if (!infoDiv) {infoDiv = document.createElement('div'); infoDiv.className = 'file-info mt-2'; container.appendChild(infoDiv)}const sizeText = this.formatFileSize(file.size); infoDiv.innerHTML = ` <div class="alert alert-info"> <strong>Wybrany plik:</strong> ${file.name}<br> <strong>Rozmiar:</strong> ${sizeText}<br> <strong>Typ:</strong> ${file.type}</div> `}showUploadProgress(form) {const template = document.querySelector('.ocr-progress-template'); const progressContainer = form.querySelector('.upload-progress') || this.createProgressContainer(form); progressContainer.innerHTML = template.innerHTML; progressContainer.classList.remove('d-none')}updateUploadProgress(percentage) {const progressBars = document.querySelectorAll('.progress-bar'); const progressTexts = document.querySelectorAll('.progress-text'); progressBars.forEach(bar => {bar.style.width = `${percentage}%`}); progressTexts.forEach(text => {if (percentage < 100) {text.textContent = `Przesyłanie... ${Math.round(percentage)}%`}else {text.textContent = 'Przetwarzanie...'}})}hideUploadProgress() {const progressContainers = document.querySelectorAll('.upload-progress'); progressContainers.forEach(container => {container.classList.add('d-none')})}handleUploadSuccess(result) {this.hideUploadProgress(); if (result.data && result.data.task_id) {this.startStatusChecking(result.data.task_id, result.data.document_id)}if (result.data && result.data.document_id) {setTimeout(() => {window.location.href = `/ocr/status/${result.data.document_id}/`}, 2000)}}startStatusChecking(taskId, documentId) {this.statusCheckCount = 0; this.statusCheckInterval = setInterval(async () => {try {const result = await OCRAJAXHelper.checkStatus(taskId); if (result.data && (result.data.status === 'completed' || result.data.status === 'failed')) {this.stopStatusChecking(); this.handleStatusComplete(result.data)}this.statusCheckCount++; if (this.statusCheckCount >= this.maxStatusChecks) {this.stopStatusChecking(); this.showMessage('Sprawdzanie statusu zostało przerwane po przekroczeniu limitu czasu.', 'warning')}}catch (error) {console.error('Status check failed:', error); this.stopStatusChecking()}}, 5000)}stopStatusChecking() {if (this.statusCheckInterval) {clearInterval(this.statusCheckInterval); this.statusCheckInterval = null}}handleStatusComplete(statusData) {if (statusData.status === 'completed') {this.showMessage('Przetwarzanie OCR zostało zakończone pomyślnie!', 'success')}else if (statusData.status === 'failed') {this.showMessage(`Przetwarzanie OCR nie powiodło się: ${statusData.error_message || 'Nieznany błąd'}`, 'error')}}updateStatusDisplay(result, container) {if (!container) return; const statusElement = container.querySelector('.status-value'); const progressElement = container.querySelector('.progress-value'); const messageElement = container.querySelector('.status-message'); if (result.data) {if (statusElement) {statusElement.textContent = this.translateStatus(result.data.status)}if (progressElement && result.data.progress !== undefined) {progressElement.textContent = `${result.data.progress}%`}if (messageElement && result.data.message) {messageElement.textContent = result.data.message}}}createProgressContainer(form) {const container = document.createElement('div'); container.className = 'upload-progress d-none mt-3'; form.appendChild(container); return container}formatFileSize(bytes) {if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]}translateStatus(status) {const translations = {'pending': 'Oczekuje', 'processing': 'Przetwarzanie', 'completed': 'Zakończone', 'failed': 'Błąd', 'queued': 'W kolejce' }; return translations[status] || status}showMessage(message, type = 'info') {if (window.Toastify) {const backgroundColor = {'success': '#28a745', 'error': '#dc3545', 'warning': '#ffc107', 'info': '#17a2b8' }[type] || '#17a2b8'; Toastify({text: message, duration: 5000, gravity: 'top', position: 'right', backgroundColor: backgroundColor, stopOnFocus: true }).showToast(); return}alert(message)}}if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', function() {window.ocrHandler = new OCRHandler()})}else {window.ocrHandler = new OCRHandler()}window.OCRHandler = OCRHandler})(window);
class PageManager {constructor() {this.init()}init() {if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', () => this.initializePage())}else {this.initializePage()}}initializePage() {console.log('PageManager: Initializing page functionality...'); this.initializeLoadingStates(); this.initializeForms(); this.initializeModals(); this.initializeTables(); this.initializeTooltips(); this.initializePagination(); this.initializeSearch(); this.initializeFileUploads(); this.initializeConfirmDialogs(); this.initializePageSpecificFeatures(); console.log('PageManager: Page functionality initialized successfully')}initializeLoadingStates() {const forms = document.querySelectorAll('form'); forms.forEach(form => {form.addEventListener('submit', (e) => {const submitBtn = form.querySelector('button[type="submit"], input[type="submit"]'); if (submitBtn && !submitBtn.disabled) {this.setLoadingState(submitBtn, true); setTimeout(() => {this.setLoadingState(submitBtn, false)}, 10000)}})}); const ajaxButtons = document.querySelectorAll('[data-ajax]'); ajaxButtons.forEach(button => {button.addEventListener('click', () => {this.setLoadingState(button, true)})})}setLoadingState(element, isLoading) {if (isLoading) {element.disabled = true; element.dataset.originalText = element.textContent; element.innerHTML = '<i class="ri-loader-4-line spin"></i> Ładowanie...'; element.classList.add('loading')}else {element.disabled = false; element.textContent = element.dataset.originalText || element.textContent; element.classList.remove('loading')}}initializeForms() {const forms = document.querySelectorAll('form'); forms.forEach(form => {const inputs = form.querySelectorAll('input, select, textarea'); inputs.forEach(input => {input.addEventListener('blur', () => {this.validateField(input)}); input.addEventListener('input', () => {this.clearFieldValidation(input)})}); form.addEventListener('submit', (e) => {if (!this.validateForm(form)) {e.preventDefault()}})}); const autosaveForms = document.querySelectorAll('form[data-autosave]'); autosaveForms.forEach(form => {this.initializeAutosave(form)})}validateField(field) {const isValid = field.checkValidity(); if (!isValid) {field.classList.add('is-invalid'); this.showFieldError(field, field.validationMessage)}else {field.classList.remove('is-invalid'); field.classList.add('is-valid'); this.hideFieldError(field)}return isValid}clearFieldValidation(field) {field.classList.remove('is-invalid', 'is-valid'); this.hideFieldError(field)}validateForm(form) {let isValid = true; const inputs = form.querySelectorAll('input, select, textarea'); inputs.forEach(input => {if (!this.validateField(input)) {isValid = false}}); return isValid}showFieldError(field, message) {let errorDiv = field.parentNode.querySelector('.invalid-feedback'); if (!errorDiv) {errorDiv = document.createElement('div'); errorDiv.className = 'invalid-feedback'; field.parentNode.appendChild(errorDiv)}errorDiv.textContent = message}hideFieldError(field) {const errorDiv = field.parentNode.querySelector('.invalid-feedback'); if (errorDiv) {errorDiv.remove()}}initializeAutosave(form) {let autosaveTimeout; const inputs = form.querySelectorAll('input, select, textarea'); inputs.forEach(input => {input.addEventListener('input', () => {clearTimeout(autosaveTimeout); autosaveTimeout = setTimeout(() => {this.autosaveForm(form)}, 2000)})})}async autosaveForm(form) {try {const formData = new FormData(form); const response = await fetch(form.action + '?autosave=1', {method: 'POST', body: formData, headers: {'X-CSRFToken': this.getCSRFToken() }}); if (response.ok) {this.showMessage('Zmiany zostały automatycznie zapisane', 'success', 2000)}}catch (error) {console.error('Autosave failed:', error)}}initializeModals() {const modals = document.querySelectorAll('.modal'); modals.forEach(modal => {modal.addEventListener('shown.bs.modal', () => {const firstInput = modal.querySelector('input, select, textarea'); if (firstInput) {firstInput.focus()}}); modal.addEventListener('hidden.bs.modal', () => {const form = modal.querySelector('form'); if (form && form.dataset.clearOnClose !== 'false') {form.reset(); this.clearFormValidation(form)}})}); const modalTriggers = document.querySelectorAll('[data-bs-toggle="modal"]'); modalTriggers.forEach(trigger => {trigger.addEventListener('click', (e) => {const targetModal = document.querySelector(trigger.dataset.bsTarget); if (targetModal) {const loadUrl = trigger.dataset.loadUrl; if (loadUrl) {this.loadModalContent(targetModal, loadUrl)}}})})}async loadModalContent(modal, url) {const modalBody = modal.querySelector('.modal-body'); if (!modalBody) return; try {modalBody.innerHTML = '<div class="text-center"><i class="ri-loader-4-line spin"></i> Ładowanie...</div>'; const response = await fetch(url); const content = await response.text(); modalBody.innerHTML = content; this.initializeLoadedContent(modalBody)}catch (error) {console.error('Failed to load modal content:', error); modalBody.innerHTML = '<div class="alert alert-danger">Błąd podczas ładowania zawartości</div>'}}clearFormValidation(form) {const inputs = form.querySelectorAll('input, select, textarea'); inputs.forEach(input => {this.clearFieldValidation(input)})}initializeTables() {const tables = document.querySelectorAll('table'); tables.forEach(table => {if (!table.closest('.table-responsive')) {const wrapper = document.createElement('div'); wrapper.className = 'table-responsive'; table.parentNode.insertBefore(wrapper, table); wrapper.appendChild(table)}this.initializeTableSelection(table); if (!table.classList.contains('dataTable')) {this.initializeTableSorting(table)}}); const bulkActionForms = document.querySelectorAll('form[data-bulk-action]'); bulkActionForms.forEach(form => {this.initializeBulkActions(form)})}initializeTableSelection(table) {const selectAllCheckbox = table.querySelector('thead input[type="checkbox"]'); const rowCheckboxes = table.querySelectorAll('tbody input[type="checkbox"]'); if (selectAllCheckbox && rowCheckboxes.length > 0) {selectAllCheckbox.addEventListener('change', () => {rowCheckboxes.forEach(checkbox => {checkbox.checked = selectAllCheckbox.checked; this.toggleRowSelection(checkbox.closest('tr'), checkbox.checked)}); this.updateBulkActionButtons()}); rowCheckboxes.forEach(checkbox => {checkbox.addEventListener('change', () => {this.toggleRowSelection(checkbox.closest('tr'), checkbox.checked); this.updateSelectAllState(selectAllCheckbox, rowCheckboxes); this.updateBulkActionButtons()})})}}toggleRowSelection(row, isSelected) {if (isSelected) {row.classList.add('table-active')}else {row.classList.remove('table-active')}}updateSelectAllState(selectAllCheckbox, rowCheckboxes) {const checkedCount = Array.from(rowCheckboxes).filter(cb => cb.checked).length; const totalCount = rowCheckboxes.length; selectAllCheckbox.checked = checkedCount === totalCount; selectAllCheckbox.indeterminate = checkedCount > 0 && checkedCount < totalCount}updateBulkActionButtons() {const selectedCount = document.querySelectorAll('tbody input[type="checkbox"]:checked').length; const bulkButtons = document.querySelectorAll('[data-bulk-action]'); bulkButtons.forEach(button => {button.disabled = selectedCount === 0; const countSpan = button.querySelector('.selected-count'); if (countSpan) {countSpan.textContent = selectedCount}})}initializeTableSorting(table) {const headers = table.querySelectorAll('th[data-sortable]'); headers.forEach(header => {header.style.cursor = 'pointer'; header.addEventListener('click', () => {this.sortTable(table, header)})})}sortTable(table, header) {const columnIndex = Array.from(header.parentNode.children).indexOf(header); const tbody = table.querySelector('tbody'); const rows = Array.from(tbody.querySelectorAll('tr')); const isAscending = !header.classList.contains('sort-asc'); table.querySelectorAll('th').forEach(th => {th.classList.remove('sort-asc', 'sort-desc')}); header.classList.add(isAscending ? 'sort-asc' : 'sort-desc'); rows.sort((a, b) => {const aValue = a.children[columnIndex].textContent.trim(); const bValue = b.children[columnIndex].textContent.trim(); const comparison = aValue.localeCompare(bValue, 'pl', {numeric: true }); return isAscending ? comparison : -comparison}); rows.forEach(row => tbody.appendChild(row))}initializeBulkActions(form) {const bulkButtons = form.querySelectorAll('[data-bulk-action]'); bulkButtons.forEach(button => {button.addEventListener('click', (e) => {e.preventDefault(); const action = button.dataset.bulkAction; const selectedIds = this.getSelectedIds(); if (selectedIds.length === 0) {this.showMessage('Nie wybrano żadnych elementów', 'warning'); return}if (button.dataset.confirm) {this.showConfirmDialog(button.dataset.confirm, () => this.executeBulkAction(action, selectedIds))}else {this.executeBulkAction(action, selectedIds)}})})}getSelectedIds() {const checkboxes = document.querySelectorAll('tbody input[type="checkbox"]:checked'); return Array.from(checkboxes).map(cb => cb.value)}async executeBulkAction(action, ids) {try {const response = await fetch(`/bulk-action/${action}/`, {method: 'POST', headers: {'Content-Type': 'application/json', 'X-CSRFToken': this.getCSRFToken() }, body: JSON.stringify({ids: ids }) }); const data = await response.json(); if (data.success) {this.showMessage(data.message || 'Operacja wykonana pomyślnie', 'success'); location.reload()}else {this.showMessage(data.error || 'Wystąpił błąd', 'error')}}catch (error) {console.error('Bulk action failed:', error); this.showMessage('Wystąpił błąd podczas wykonywania operacji', 'error')}}initializeTooltips() {if (typeof bootstrap !== 'undefined' && bootstrap.Tooltip) {const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]')); tooltipTriggerList.map(function (tooltipTriggerEl) {return new bootstrap.Tooltip(tooltipTriggerEl)})}}initializePagination() {const paginationLinks = document.querySelectorAll('.pagination a'); paginationLinks.forEach(link => {link.addEventListener('click', (e) => {if (link.dataset.ajax === 'true') {e.preventDefault(); this.loadPage(link.href)}})})}async loadPage(url) {try {const response = await fetch(url, {headers: {'X-Requested-With': 'XMLHttpRequest' }}); const data = await response.json(); if (data.html) {const contentArea = document.querySelector('[data-content-area]'); if (contentArea) {contentArea.innerHTML = data.html; this.initializeLoadedContent(contentArea)}}}catch (error) {console.error('Failed to load page:', error)}}initializeSearch() {const searchForms = document.querySelectorAll('form[data-search]'); searchForms.forEach(form => {const searchInput = form.querySelector('input[type="search"], input[name="search"]'); if (searchInput) {let searchTimeout; searchInput.addEventListener('input', () => {clearTimeout(searchTimeout); searchTimeout = setTimeout(() => {if (form.dataset.liveSearch === 'true') {this.performSearch(form)}}, 500)})}})}async performSearch(form) {try {const formData = new FormData(form); const params = new URLSearchParams(formData); const response = await fetch(`${form.action}?${params}`, {headers: {'X-Requested-With': 'XMLHttpRequest' }}); const data = await response.json(); if (data.html) {const resultsArea = document.querySelector('[data-search-results]'); if (resultsArea) {resultsArea.innerHTML = data.html; this.initializeLoadedContent(resultsArea)}}}catch (error) {console.error('Search failed:', error)}}initializeFileUploads() {const fileInputs = document.querySelectorAll('input[type="file"]'); fileInputs.forEach(input => {input.addEventListener('change', (e) => {this.handleFileSelection(input)}); const wrapper = input.closest('.file-upload-wrapper'); if (wrapper) {this.initializeDragAndDrop(wrapper, input)}})}handleFileSelection(input) {const files = input.files; const preview = input.parentNode.querySelector('.file-preview'); if (preview) {preview.innerHTML = ''; Array.from(files).forEach(file => {const fileItem = document.createElement('div'); fileItem.className = 'file-item'; fileItem.innerHTML = ` <i class="ri-file-line"></i> <span>${file.name}</span> <small>(${this.formatFileSize(file.size)})</small> `; preview.appendChild(fileItem)})}}initializeDragAndDrop(wrapper, input) {['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {wrapper.addEventListener(eventName, (e) => {e.preventDefault(); e.stopPropagation()})}); ['dragenter', 'dragover'].forEach(eventName => {wrapper.addEventListener(eventName, () => {wrapper.classList.add('drag-over')})}); ['dragleave', 'drop'].forEach(eventName => {wrapper.addEventListener(eventName, () => {wrapper.classList.remove('drag-over')})}); wrapper.addEventListener('drop', (e) => {const files = e.dataTransfer.files; input.files = files; this.handleFileSelection(input)})}formatFileSize(bytes) {if (bytes === 0) return '0 Bytes'; const k = 1024; const sizes = ['Bytes', 'KB', 'MB', 'GB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]}initializeConfirmDialogs() {const confirmButtons = document.querySelectorAll('[data-confirm]'); confirmButtons.forEach(button => {button.addEventListener('click', (e) => {e.preventDefault(); const message = button.dataset.confirm; const action = () => {if (button.href) {window.location.href = button.href}else if (button.form) {button.form.submit()}}; this.showConfirmDialog(message, action)})})}showConfirmDialog(message, onConfirm) {if (typeof bootstrap !== 'undefined' && bootstrap.Modal) {this.showBootstrapConfirmDialog(message, onConfirm)}else {if (confirm(message)) {onConfirm()}}}showBootstrapConfirmDialog(message, onConfirm) {const modalHtml = ` <div class="modal fade" id="confirmModal" tabindex="-1"> <div class="modal-dialog"> <div class="modal-content"> <div class="modal-header"> <h5 class="modal-title">Potwierdzenie</h5> <button type="button" class="btn-close" data-bs-dismiss="modal"></button> </div> <div class="modal-body"> <p>${message}</p> </div> <div class="modal-footer"> <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Anuluj</button> <button type="button" class="btn btn-primary" id="confirmBtn">Potwierdź</button> </div> </div> </div> </div> `; document.body.insertAdjacentHTML('beforeend', modalHtml); const modal = new bootstrap.Modal(document.getElementById('confirmModal')); document.getElementById('confirmBtn').addEventListener('click', () => {modal.hide(); onConfirm()}); modal.show(); document.getElementById('confirmModal').addEventListener('hidden.bs.modal', () => {document.getElementById('confirmModal').remove()})}initializePageSpecificFeatures() {const pageType = document.body.dataset.pageType; switch (pageType) {case 'invoice-list': this.initializeInvoiceListFeatures(); break; case 'invoice-form': this.initializeInvoiceFormFeatures(); break; case 'dashboard': this.initializeDashboardFeatures(); break; default: break}}initializeInvoiceListFeatures() {console.log('Initializing invoice list features')}initializeInvoiceFormFeatures() {console.log('Initializing invoice form features')}initializeDashboardFeatures() {console.log('Initializing dashboard features')}initializeLoadedContent(container) {this.initializeForms(); this.initializeModals(); this.initializeTables(); this.initializeTooltips(); this.initializeFileUploads(); this.initializeConfirmDialogs()}getCSRFToken() {const token = document.querySelector('[name=csrfmiddlewaretoken]')?.value; if (!token) {const metaToken = document.querySelector('meta[name="csrf-token"]')?.content; return metaToken || ''}return token}showMessage(message, type = 'info', duration = 5000) {if (typeof Toastify !== 'undefined') {Toastify({text: message, duration: duration, gravity: "top", position: "right", backgroundColor: this.getToastColor(type) }).showToast()}else {console.log(`${type.toUpperCase()}: ${message}`)}}getToastColor(type) {const colors = {'success': '#28a745', 'error': '#dc3545', 'warning': '#ffc107', 'info': '#17a2b8' }; return colors[type] || colors.info}refresh() {this.initializePage()}}window.PageManager = new PageManager(); if (typeof module !== 'undefined' && module.exports) {module.exports = PageManager}
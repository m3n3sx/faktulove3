(function() {'use strict'; const tableState = {initialized: false, tables: new Map(), config: {defaultOptions: {responsive: true, pageLength: 25, lengthMenu: [[10, 25, 50, 100, -1], [10, 25, 50, 100, "All"]], language: {search: "Search:", lengthMenu: "Show _MENU_ entries", info: "Showing _START_ to _END_ of _TOTAL_ entries", infoEmpty: "Showing 0 to 0 of 0 entries", infoFiltered: "(filtered from _TOTAL_ total entries)", paginate: {first: "First", last: "Last", next: "Next", previous: "Previous" }, emptyTable: "No data available in table", zeroRecords: "No matching records found" }, dom: '<"row"<"col-sm-12 col-md-6"l><"col-sm-12 col-md-6"f>>' + '<"row"<"col-sm-12"tr>>' + '<"row"<"col-sm-12 col-md-5"i><"col-sm-12 col-md-7"p>>', order: [[0, 'desc']], columnDefs: [{targets: 'no-sort', orderable: false }, {targets: 'text-center', className: 'text-center' }] }}}; const utils = {log: function(message, type = 'info') {if (console && console[type]) {console[type]('[Tables Manager]', message)}}, mergeOptions: function(defaultOptions, customOptions) {return Object.assign({}, defaultOptions, customOptions)}, getTableElement: function(selector) {const table = document.querySelector(selector); if (!table) {utils.log(`Table not found: ${selector}`, 'warn'); return null}return table}, addBasicSorting: function(table) {const headers = table.querySelectorAll('th[data-sortable="true"], th.sortable'); headers.forEach((header, index) => {header.style.cursor = 'pointer'; header.style.userSelect = 'none'; if (!header.querySelector('.sort-indicator')) {const indicator = document.createElement('span'); indicator.className = 'sort-indicator'; indicator.innerHTML = ' ↕️'; indicator.style.opacity = '0.5'; header.appendChild(indicator)}header.addEventListener('click', () => {this.sortTable(table, index, header)})})}, sortTable: function(table, columnIndex, header) {const tbody = table.querySelector('tbody'); if (!tbody) return; const rows = Array.from(tbody.querySelectorAll('tr')); const isAscending = header.getAttribute('data-sort-direction') !== 'asc'; table.querySelectorAll('.sort-indicator').forEach(indicator => {indicator.innerHTML = ' ↕️'; indicator.style.opacity = '0.5'}); const indicator = header.querySelector('.sort-indicator'); if (indicator) {indicator.innerHTML = isAscending ? ' ↑' : ' ↓'; indicator.style.opacity = '1'}header.setAttribute('data-sort-direction', isAscending ? 'asc' : 'desc'); rows.sort((a, b) => {const aCell = a.cells[columnIndex]; const bCell = b.cells[columnIndex]; if (!aCell || !bCell) return 0; let aValue = aCell.textContent.trim(); let bValue = bCell.textContent.trim(); const aNum = parseFloat(aValue.replace(/[^\d.-]/g, '')); const bNum = parseFloat(bValue.replace(/[^\d.-]/g, '')); if (!isNaN(aNum) && !isNaN(bNum)) {return isAscending ? aNum - bNum : bNum - aNum}return isAscending ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue)}); rows.forEach(row => tbody.appendChild(row))}, addBasicSearch: function(table) {const searchContainer = document.createElement('div'); searchContainer.className = 'table-search-fallback'; searchContainer.style.cssText = ` margin-bottom: 15px; display: flex; justify-content: flex-end; align-items: center; gap: 10px; `; const searchLabel = document.createElement('label'); searchLabel.textContent = 'Search:'; searchLabel.style.fontWeight = 'bold'; const searchInput = document.createElement('input'); searchInput.type = 'text'; searchInput.className = 'form-control'; searchInput.style.width = '200px'; searchInput.placeholder = 'Search table...'; searchContainer.appendChild(searchLabel); searchContainer.appendChild(searchInput); table.parentNode.insertBefore(searchContainer, table); searchInput.addEventListener('input', (e) => {this.filterTable(table, e.target.value)})}, filterTable: function(table, searchTerm) {const tbody = table.querySelector('tbody'); if (!tbody) return; const rows = tbody.querySelectorAll('tr'); const term = searchTerm.toLowerCase(); rows.forEach(row => {const text = row.textContent.toLowerCase(); row.style.display = text.includes(term) ? '' : 'none'})}, addBasicPagination: function(table, pageSize = 25) {const tbody = table.querySelector('tbody'); if (!tbody) return; const rows = Array.from(tbody.querySelectorAll('tr')); if (rows.length <= pageSize) return; let currentPage = 0; const totalPages = Math.ceil(rows.length / pageSize); const paginationContainer = document.createElement('div'); paginationContainer.className = 'table-pagination-fallback'; paginationContainer.style.cssText = ` margin-top: 15px; display: flex; justify-content: space-between; align-items: center; `; const infoDiv = document.createElement('div'); infoDiv.className = 'pagination-info'; const controlsDiv = document.createElement('div'); controlsDiv.className = 'pagination-controls'; controlsDiv.style.cssText = ` display: flex; gap: 5px; align-items: center; `; const prevBtn = document.createElement('button'); prevBtn.textContent = 'Previous'; prevBtn.className = 'btn btn-sm btn-outline-primary'; const nextBtn = document.createElement('button'); nextBtn.textContent = 'Next'; nextBtn.className = 'btn btn-sm btn-outline-primary'; const pageInfo = document.createElement('span'); pageInfo.style.margin = '0 10px'; controlsDiv.appendChild(prevBtn); controlsDiv.appendChild(pageInfo); controlsDiv.appendChild(nextBtn); paginationContainer.appendChild(infoDiv); paginationContainer.appendChild(controlsDiv); table.parentNode.insertBefore(paginationContainer, table.nextSibling); const showPage = (page) => {const start = page * pageSize; const end = start + pageSize; rows.forEach((row, index) => {row.style.display = (index >= start && index < end) ? '' : 'none'}); const visibleStart = start + 1; const visibleEnd = Math.min(end, rows.length); infoDiv.textContent = `Showing ${visibleStart}to ${visibleEnd}of ${rows.length}entries`; pageInfo.textContent = `Page ${page + 1}of ${totalPages}`; prevBtn.disabled = page === 0; nextBtn.disabled = page === totalPages - 1}; prevBtn.addEventListener('click', () => {if (currentPage > 0) {currentPage--; showPage(currentPage)}}); nextBtn.addEventListener('click', () => {if (currentPage < totalPages - 1) {currentPage++; showPage(currentPage)}}); showPage(currentPage)}, enhanceTableFallback: function(table) {utils.log(`Enhancing table with fallback features: ${table.id || 'unnamed'}`); if (!table.classList.contains('table')) {table.classList.add('table', 'table-striped', 'table-hover')}this.addBasicSorting(table); this.addBasicSearch(table); this.addBasicPagination(table)}}; const dataTablesInit = {initializeTable: function(selector, options = {}) {const table = utils.getTableElement(selector); if (!table) return null; if (typeof $.fn.DataTable === 'undefined') {utils.log(`DataTables not available for ${selector}, using fallback`, 'warn'); utils.enhanceTableFallback(table); return null}const mergedOptions = utils.mergeOptions(tableState.config.defaultOptions, options); try {if ($.fn.DataTable.isDataTable(table)) {utils.log(`Table ${selector}already initialized`); return $(table).DataTable()}const dataTable = $(table).DataTable(mergedOptions); tableState.tables.set(selector, dataTable); utils.log(`DataTable initialized: ${selector}`); return dataTable}catch (error) {utils.log(`Failed to initialize DataTable ${selector}: ${error.message}`, 'error'); utils.enhanceTableFallback(table); return null}}, initializeInvoicesTable: function() {return this.initializeTable('#invoicesTable', {order: [[0, 'desc']], columnDefs: [{targets: [0], type: 'date' }, {targets: [-1], orderable: false }, {targets: [3, 4], className: 'text-end' }] })}, initializeContractorsTable: function() {return this.initializeTable('#contractorsTable', {order: [[1, 'asc']], columnDefs: [{targets: [-1], orderable: false }, {targets: [0], visible: false }] })}, initializeOCRResultsTable: function() {return this.initializeTable('#ocrResultsTable', {order: [[0, 'desc']], columnDefs: [{targets: [0], type: 'date' }, {targets: [2], className: 'text-center' }, {targets: [3], className: 'text-center' }, {targets: [-1], orderable: false }] })}, initializeGenericTable: function(selector) {return this.initializeTable(selector, {})}}; const tablesManager = {init: function() {utils.log('Initializing tables manager'); if (typeof $ === 'undefined') {utils.log('jQuery not available, waiting for dependency manager', 'warn'); this.waitForDependencies(); return}if (typeof $.fn.DataTable === 'undefined') {utils.log('DataTables not available, waiting for dependency manager', 'warn'); this.waitForDependencies(); return}this.initializeAllTables()}, waitForDependencies: function() {document.addEventListener('datatables:ready', () => {utils.log('DataTables ready event received'); this.initializeAllTables()}); if (window.DependencyManager) {window.DependencyManager.whenReady('DataTables', (error) => {if (error) {utils.log(`DataTables failed to load: ${error.message}`, 'error'); this.initializeFallbackTables()}else {utils.log('DataTables loaded via DependencyManager'); this.initializeAllTables()}})}setTimeout(() => {if (!tableState.initialized) {utils.log('DataTables loading timeout, using fallbacks', 'warn'); this.initializeFallbackTables()}}, 5000)}, initializeAllTables: function() {if (tableState.initialized) {utils.log('Tables already initialized'); return}utils.log('Initializing all tables'); try {dataTablesInit.initializeInvoicesTable(); dataTablesInit.initializeContractorsTable(); dataTablesInit.initializeOCRResultsTable(); document.querySelectorAll('[data-table="true"]').forEach(table => {const selector = `#${table.id}`; if (table.id && !tableState.tables.has(selector)) {dataTablesInit.initializeGenericTable(selector)}}); document.querySelectorAll('.dataTable').forEach(table => {const selector = `#${table.id}`; if (table.id && !tableState.tables.has(selector)) {dataTablesInit.initializeGenericTable(selector)}}); tableState.initialized = true; utils.log('All tables initialized successfully'); document.dispatchEvent(new CustomEvent('tables:initialized'))}catch (error) {utils.log(`Table initialization failed: ${error.message}`, 'error'); this.initializeFallbackTables()}}, initializeFallbackTables: function() {utils.log('Initializing fallback table enhancements'); const tables = document.querySelectorAll('table'); tables.forEach(table => {if (table.classList.contains('no-enhance')) return; utils.enhanceTableFallback(table)}); tableState.initialized = true; utils.log('Fallback table enhancements applied')}, destroyTable: function(selector) {const dataTable = tableState.tables.get(selector); if (dataTable) {try {dataTable.destroy(); tableState.tables.delete(selector); utils.log(`Table destroyed: ${selector}`)}catch (error) {utils.log(`Failed to destroy table ${selector}: ${error.message}`, 'error')}}}, refreshTable: function(selector) {const dataTable = tableState.tables.get(selector); if (dataTable) {try {dataTable.ajax.reload(); utils.log(`Table refreshed: ${selector}`)}catch (error) {utils.log(`Failed to refresh table ${selector}: ${error.message}`, 'error')}}}, destroyAllTables: function() {tableState.tables.forEach((dataTable, selector) => {this.destroyTable(selector)}); tableState.initialized = false}}; if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded', () => {tablesManager.init()})}else {tablesManager.init()}window.TablesManager = {init: tablesManager.init.bind(tablesManager), initializeTable: dataTablesInit.initializeTable.bind(dataTablesInit), destroyTable: tablesManager.destroyTable.bind(tablesManager), refreshTable: tablesManager.refreshTable.bind(tablesManager), destroyAllTables: tablesManager.destroyAllTables.bind(tablesManager) }})();